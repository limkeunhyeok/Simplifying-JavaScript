# 자바스크립트 코딩의 기술

## 8장 클래스로 인터페이스를 간결하게 유지하라

### TIP 37 읽기 쉬운 클래스를 만들어라

```javascript
class Coupon {
  constructor(price, expiration) {
    this.price = price;
    this.expiration = expiration;
  }

  getPriceText() {
    return `$ ${this.price}`;
  }

  getExpirationMessage() {
    return `이 쿠폰은 ${this.expiration} 후에 만료됩니다.`;
  }
}

const coupon = new Coupon(5);
coupon.getPriceText(); // "$ 5"
coupon.getExpirationMessage(); // "이 쿠폰은 2주 후에 만료됩니다."
```

- 생성자의 역활 중 하나는 this 문맥을 생성하는 것이다.
- 현재 ES2019에서 # prefix를 추가하여 private 선언이 가능하다.

### TIP 38 상속으로 메서드를 공유하라

```javascript
class FlashCoupon extends Coupon{
  constructor(price, expiration) {
    super(price);
    this.expiration = expiration || "2시간";
  }

  getExpirationMessage() {
    return `이 쿠폰은 깜짝 쿠폰이며 ${this.expiration} 후에 만료됩니다.`;
  }
}
```

- 상속을 사용할 때는 주의가 필요하다.
  - 지나친 상속은 나쁜 것이며 비대한 코드로 이어질 수 있다.
  - 메서드를 공유하기 위해 composition을 사용할 수도 있다.
- 새로운 속성이나 메서드를 추가할 것이 아니라면 상속에는 아무론 의미가 없다.
- 새로운 생성자에서 부모 클래스의 생성자를 호출하려면 super()를 호출해야 한다.
  - 부모 클래스의 생성자에 필요한 인수가 있다면 super()를 이용해서 넘겨줘야 한다.
- 클래스에 같은 이름의 메서드를 새로 작성하면 부모 클래스에서 상속한 메서드를 대체한다.
  - 자식 클래스에서 필요하지 않는 메서드를 부모 클래스에 추가하면 자식 클래스가 비대해지기 쉽다.
- 자바스크립트는 프로토타입 기반 언어이며, 클래스는 다른 패러다임을 위해 제공되는 익숙한 문법에 불과하다.
  - 내부적으로는 기존과 동일한 프로토타입 기반의 동작을 하기 때문에 레거시 코드와 클래스를 결합할 수 있는 이점이 있다.

### TIP 39 클래스로 기존의 프로토타입을 확장하라

- 자바스크립트에서는 새로운 인스턴스를 생성할 때 메서드를 복제하지 않는다.
  - 그 대신 프로토타입에 대한 연결을 생성한다.
  - 객체의 인스턴스에 있는 메서드를 호출하면 프로토타입에 있는 메서드를 호출한다.
- 함수를 생성자로 사용하려면 코딩 컨벤션으로 함수명을 대문자로 시작한다.
  - 생성자에서 this에 메서드를 추가할 수도 있지만, 프로토타입에 직접 추가하는 것이 훨씬 더 효율적이다.
- 프로토타입은 생성자 함수의 기반이 되는 객체이며, 모든 객체 인스턴스는 프로토타입에서 속성을 가져온다.
- class 키워드를 이용해도 프로토타입을 생성하고 문맥을 바인딩하지만, 더욱 직관적인 인터페이스를 사용할 수 있다.

### TIP 40 get과 set으로 인터페이스를 단순하게 만들어라

- 게터와 세터를 이용해서 로직을 추가하고 속성을 뒤로 숨길 수 있다.
- 게터는 메서드 앞에 get 키워드를 추가하면 된다.
  - 함수 이름을 동작 대신 명사로 수정할 수 있다.
  - 코딩 컨벤션으로 메서드나 함수는 동사로 시작하게 하고, 속성은 명사로 한다.
- 세터는 메서드 앞에 set 키워드를 추가하면 된다.
  - 세터의 경우에는 인수를 하나만 받고, 정보를 노출하는 것이 아니라 속성을 변경한다.
- 게터와 세터는 항상 짝을 맞춰서 만드는 것이 좋다.
  - 게터와 세터는 같은 이름을 가질 수 있으며, 같은 이름의 속성은 둘 수 없다.
- 게터와 세터는 복잡도를 숨길 수 있다.
  - 단점은 이와 함께 의도까지 가려진다.
    - 실제로 메서드를 호출하지만 속성을 설정한다고 생각할 수 있으며, 게터와 세터는 때때로 디버깅하기가 어렵고 테스트하기도 어렵다.

### TIP 41 제너레이터로 이터러블 속성을 생성하라

- 객체는 직접적으로 순회할 수 없으며, 일부를 먼저 배열로 변환해야 한다.
- 제너레이터란 함수가 호출되었을 때 그 즉시 끝까지 실행하지 않고 중간에 빠져나갔다가 다시 돌아올 수 있는 함수이다.
- 제너레이터는 함수 몸체의 실행을 즉시 끝내지 않는 하나의 함수이다.
  - 제너레이터는 다음 단계 전까지 기본적으로 일시 정지하는 중단점이 있는 함수이다.

```javascript
function* getCairoTrilogy() {
  yield "궁전 샛길";
  yield "욕망의 궁전";
  yield "설탕 거리";
}

const trilogy = getCairoTrilogy();
trilogy.next(); // { value: "궁전 샛길", done: false }
trilogy.next(); // { value: "욕망의 궁전", done: false }
trilogy.next(); // { value: "설탕 거리", done: false }
trilogy.next(); // { value: undefined, done: true }
```

- 제너레이터를 생성하려면 function 키워드 뒤에 *을 추가한다.
- 제너레이터는 함수의 일부를 반환하는 next()라는 특별한 메서드에 접근할 수 있다.
- 함수 몸체 안에서는 yield 키워드를 이용해 정보를 반환한다.
- next()를 호출하면 value와 done이 있는 객체를 가져온다.
  - yield로 선언한 항목이 value이고, done은 남은 항목이 없다는 것을 알려준다.
- 제너레이터는 배열의 인덱스나 맵의 키를 다루는 것처럼 각 항목을 한 번에 하나씩 거쳐간다.
- 제너레이터를 사용할 때의 이점은 다른 개발자들이 클래스의 세부 구현 내용을 알 필요가 없다는 것이다.

### TIP 42 bind()로 문맥 문제를 해결하라

```javascript
function sayMessage() {
  return this.message;
}

const alert = {
  message: "위험",
};

const sayAlert = sayMessage.bind(alert);
sayAlert(); // 위험
```

- bind() 메서드를 이용하면 문맥을 명시적으로 정할 수 있다.
  - this를 다루다가 예상하지 못한 동작이나 오류와 마주치면 명시적으로 문맥을 연결할 수 있다.